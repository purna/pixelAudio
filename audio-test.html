<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-btn { 
            padding: 10px 20px; 
            margin: 10px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer;
        }
        .test-btn:hover { background: #0056b3; }
        .log { 
            background: #f8f9fa; 
            border: 1px solid #dee2e6; 
            padding: 10px; 
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Pixel Audio - Audio Test</h1>
    <p>Open the browser console to see detailed logs. Test the audio functionality:</p>
    
    <button class="test-btn" onclick="testBasicAudio()">Test Basic Audio</button>
    <button class="test-btn" onclick="testAudioContext()">Test AudioContext</button>
    <button class="test-btn" onclick="testSoundGeneration()">Test Sound Generation</button>
    <button class="test-btn" onclick="testPresetPlayback()">Test Preset Playback</button>
    
    <div class="log" id="log"></div>

    <script>
        // Simple logging
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        // Test basic AudioContext
        async function testBasicAudio() {
            log('=== Testing Basic Audio ===');
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log(`✓ AudioContext created: ${audioContext.state}`);
                
                if (audioContext.state === 'suspended') {
                    log('AudioContext is suspended, attempting to resume...');
                    await audioContext.resume();
                    log(`✓ AudioContext resumed: ${audioContext.state}`);
                }
                
                // Create a simple test tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
                
                log('✓ Test tone played for 0.5 seconds');
                audioContext.close();
            } catch (error) {
                log(`✗ Error: ${error.message}`);
            }
        }

        // Test AudioContext state management
        async function testAudioContext() {
            log('=== Testing AudioContext State Management ===');
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log(`Initial state: ${audioContext.state}`);
                
                // Simulate user interaction
                const resumePromise = audioContext.resume();
                log('Attempting to resume...');
                await resumePromise;
                log(`After resume: ${audioContext.state}`);
                
                audioContext.close();
                log('✓ AudioContext state management working');
            } catch (error) {
                log(`✗ Error: ${error.message}`);
            }
        }

        // Test sound generation like the app does
        async function testSoundGeneration() {
            log('=== Testing Sound Generation ===');
            try {
                // Import the sound generator logic
                class TestSoundGenerator {
                    generate(settings, sampleRate = 44100) {
                        const duration = settings.attack + settings.sustain + settings.decay;
                        const samples = Math.floor(duration * sampleRate);
                        
                        const context = new (window.AudioContext || window.webkitAudioContext)();
                        const buffer = context.createBuffer(1, samples, context.sampleRate);
                        const data = buffer.getChannelData(0);

                        // Simple square wave generation
                        let phase = 0;
                        const gainLinear = Math.pow(10, settings.gain / 20);
                        
                        for (let i = 0; i < data.length; i++) {
                            const t = i / sampleRate;
                            const envelope = this.calculateEnvelope(t, settings);
                            
                            phase += (settings.frequency / sampleRate) * Math.PI * 2;
                            const sample = (phase % (Math.PI * 2)) < Math.PI ? 1 : -1;
                            
                            data[i] = sample * envelope * gainLinear;
                        }
                        
                        context.close();
                        return buffer;
                    }

                    calculateEnvelope(t, settings) {
                        if (t < settings.attack) {
                            return t / settings.attack;
                        } else if (t < settings.attack + settings.sustain) {
                            return 1;
                        } else {
                            const decayT = (t - settings.attack - settings.sustain) / settings.decay;
                            return 1 - decayT;
                        }
                    }
                }

                const generator = new TestSoundGenerator();
                const settings = {
                    attack: 0.01,
                    sustain: 0.1,
                    decay: 0.2,
                    frequency: 440,
                    gain: -10
                };

                const buffer = generator.generate(settings);
                log(`✓ Generated buffer with ${buffer.length} samples`);
                
                // Test playback
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume();
                
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();
                
                log('✓ Sound generated and played successfully');
                audioContext.close();
            } catch (error) {
                log(`✗ Error: ${error.message}`);
            }
        }

        // Test preset-like playback
        async function testPresetPlayback() {
            log('=== Testing Preset Playback ===');
            try {
                // Simulate the preset loading process
                const preset = {
                    attack: 0,
                    sustain: 0.075,
                    punch: 48,
                    decay: 0.053,
                    frequency: 1243,
                    minFreq: 3,
                    slide: 0,
                    deltaSlide: 0,
                    vibratoEnable: false,
                    vibratoDepth: 0,
                    vibratoSpeed: 0,
                    arpEnable: true,
                    arpMult: 1.18,
                    arpSpeed: 0.085,
                    duty: 50,
                    dutySweep: 0,
                    waveform: 'square',
                    lpfEnable: false,
                    lpf: 22050,
                    hpfEnable: false,
                    hpf: 0,
                    gain: -10.93
                };

                // Generate sound like the app does
                class TestSoundGenerator {
                    generate(settings, sampleRate = 44100) {
                        const duration = settings.attack + settings.sustain + settings.decay;
                        const samples = Math.floor(duration * sampleRate);
                        
                        const context = new (window.AudioContext || window.webkitAudioContext)();
                        const buffer = context.createBuffer(1, samples, context.sampleRate);
                        const data = buffer.getChannelData(0);

                        // Simplified generation
                        let phase = 0;
                        const gainLinear = Math.pow(10, settings.gain / 20);
                        
                        for (let i = 0; i < data.length; i++) {
                            const t = i / sampleRate;
                            const envelope = this.calculateEnvelope(t, settings);
                            
                            phase += (settings.frequency / sampleRate) * Math.PI * 2;
                            const sample = Math.sin(phase); // Using sine for simplicity
                            
                            data[i] = sample * envelope * gainLinear;
                        }
                        
                        context.close();
                        return buffer;
                    }

                    calculateEnvelope(t, settings) {
                        let envelope = 0;
                        if (t < settings.attack) {
                            envelope = t / settings.attack;
                        } else if (t < settings.attack + settings.sustain) {
                            envelope = 1;
                            if (settings.punch > 0) {
                                const punchT = (t - settings.attack) / settings.sustain;
                                envelope += (settings.punch / 100) * (1 - punchT);
                            }
                        } else {
                            const decayT = (t - settings.attack - settings.sustain) / settings.decay;
                            envelope = 1 - decayT;
                        }
                        return Math.max(0, Math.min(1, envelope));
                    }
                }

                const generator = new TestSoundGenerator();
                const buffer = generator.generate(preset);
                
                log(`✓ Preset sound generated: ${buffer.length} samples, duration: ${buffer.duration.toFixed(3)}s`);
                
                // Test playback like the app does
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume();
                
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();
                
                log('✓ Preset sound played successfully!');
                audioContext.close();
            } catch (error) {
                log(`✗ Error: ${error.message}`);
            }
        }

        // Initialize
        log('Audio test page loaded. Click buttons to test audio functionality.');
        log('Note: Audio may not work until you interact with the page due to browser autoplay policies.');
    </script>
</body>
</html>